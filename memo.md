**OAuth 2.0**

- **OAuth 2.0 の基礎**

  - OAuth 2.0 の目的とユースケース
    - リソース所有者が自身の所有するリソースへのアクセス権を第三者アプリケーションに安全に委任するための認可フレームワーク
    - ユーザーが第三者に対して自分がどのような人物であるかを示し、認証を行う仕組み
    - Webアプリケーション、モバイルアプリ、APIなど、多様なユースケース
  - OAuth 2.0 の基本用語
    - アクセストークン: 保護されたリソースにアクセスするための鍵
    - リソースオーナー: リソースの所有者（例: Google Photo のユーザー）
    - クライアント: リソースにアクセスしたい第三者アプリケーション
    - リソースサーバー: リソースを保管しているサーバー
    - 認可サーバー: アクセストークンを発行するサーバー
    - 認可グラント: アクセストークンを取得するための方法
    - スコープ: リソースへのアクセス範囲
  - OAuth 2.0 の基本的なフロー
    - 認可リクエスト
    - 認可グラント
    - アクセストークン発行
    - リソースアクセス
  - OAuth 2.0 のグラントタイプ
    - 認可コードグラントフロー
      - Webアプリケーションで広く使われている、最も安全なフロー
      - 認可コードをアクセストークンに交換するプロセスを含む
    - インプリシットグラントフロー
      - セキュリティ上の問題から非推奨
      - アクセストークンを直接取得するため、認可コードフローに比べて脆弱
    - パスワードグラントフロー
    - クライアントクレデンシャルグラントフロー

- **OAuth 2.0 の詳細**

  - クライアントタイプ
    - Confidential Client:
      クライアントシークレットを安全に管理できるクライアント
    - Public Client: クライアントシークレットを安全に管理できないクライアント
  - クライアント認証
    - Confidential Client が認可サーバーに自身を証明するための仕組み
    - client_secret_basic、client_secret_post など
  - リダイレクト URI
    - 認可サーバーが認可完了後にリソースオーナーをリダイレクトするURI
    - セキュリティ上の理由から適切に検証することが重要
  - アクセストークンの形式
    - OAuth 2.0 の仕様では未定義
    - Bearer Token, MAC タイプトークン, Proof Token など
  - トークンの失効
    - 発行されたアクセストークンやリフレッシュトークンを失効させる仕組み
  - セキュリティの考慮事項
    - トークン substitution 攻撃、認可コード横取り攻撃、CSRF 攻撃など
    - トークンの完全性、機密性、データ生成元の認証

- **OAuth 2.0 のベストプラクティス**
  - RFC 6819 (OAuth 2.0 Threat Model and Security Considerations)
    - 脅威モデル、セキュリティ上の考慮事項、アクセストークンの形式
  - OAuth 2.0 Security Best Current Practice
    - インプリシットフローの非推奨、PKCE の推奨など
  - OAuth 2.1 (ドラフト)
    - インプリシットフローの削除

**OpenID Connect (OIDC)**

- **OpenID Connect の基礎**

  - OpenID Connect の目的とユースケース
    - OAuth 2.0 を拡張し、認証のためのアイデンティティレイヤーを提供
    - ユーザーの認証と基本的なプロフィール情報の取得
  - OpenID Connect の基本用語
    - ID トークン: ユーザーの認証結果とプロフィール情報を表現するトークン
    - リライングパーティ (RP): クライアントアプリケーション
    - OpenID プロバイダー (OP): 認証サーバー
    - UserInfo エンドポイント:
      ユーザーのプロフィール情報を提供するエンドポイント
  - ID トークンの構造とクレーム
    - JSON Web Token (JWT) 形式
    - Issuer (iss), Subject (sub), Audience (aud) など
  - OpenID Connect のフロー
    - Authorization Code Flow, Implicit Flow, Hybrid Flow
    - 認可コードフローをベースに、ID トークンの取得プロセスを追加

- **OpenID Connect の詳細**

  - OpenID Connect Discovery 1.0
    - OpenID プロバイダーの設定情報を取得するための仕組み
  - エラーレスポンス
    - interaction_required, login_required, account_selection_required など
  - Request Object
    - 認可リクエストのパラメータを JWT 形式で渡す仕組み
  - セキュリティの考慮事項
    - トークン substitution 攻撃、リプレイ攻撃など
    - ID トークンの署名と検証によるセキュリティ強化

- **OpenID Connect の応用**
  - Financial-grade API (FAPI)
    - 金融機関レベルのセキュリティ要件を満たす API のための仕様
  - Device Flow
    - スマートTV、ゲーム機など、入力機能が制限されたデバイスでの認証
  - CIBA (Client Initiated Backchannel Authentication)
    - ユーザーがブラウザを使用しない、サーバーサイドでの認証
  - Identity Assurance
    - 認証レベルの強化、多要素認証など
  - OpenID Connect Implementer's Guide

**学習教材とリソース**

- **仕様書**
  - RFC 6749 (The OAuth 2.0 Authorization Framework)
    - OAuth 2.0 の基本仕様
  - OpenID Connect Core 1.0
    - OpenID Connect の基本仕様
  - RFC 7636 (Proof Key for Code Exchange)
    - PKCE の仕様
  - その他の関連仕様
- **書籍**
  - OAuth & OIDC 入門編
- **ブログ記事**
  - Authlete のブログ記事
  - Qiita の記事
- **オンラインチュートリアル**
  - Auth0 のチュートリアル
  - Okta のチュートリアル
- **サンプルコード**
  - OAuth 2.0 / OpenID Connect ライブラリのサンプルコード
  - GitHub 上のサンプルプロジェクト

**学習のヒント**

- **段階的な学習**: OAuth 2.0 の基礎をしっかり理解してから OpenID Connect に進む
- **実践**: サンプルコードやオンラインチュートリアルを利用して実際に実装してみる
- **セキュリティ**: セキュリティの考慮事項を常に意識する

**1. インプリシットフローの回避**:
インプリシットフローは、アクセストークンがブラウザの履歴や HTTP
リファラーヘッダーに残る可能性があるため、セキュリティ上のリスクが高いとされています。そのため、**認可コードグラントフロー**の使用が強く推奨されます。OAuth
2.0 Security Best Current Practice や OAuth 2.1 のドラフト
では、インプリシットフローは非推奨とされています。

**2. PKCE (Proof Key for Code Exchange) の導入**: PKCE
は、認可コード横取り攻撃を防止するためのセキュリティ機構です。特に** Public
Client** で認可コードグラントフローを使用する場合には、PKCE
の導入が必須となります。PKCE
を使用することで、悪意のある第三者アプリケーションが認可コードを盗み出してアクセストークンを取得することを防ぐことができます。

**3. state パラメータの使用**: `state` パラメータは、CSRF (Cross-Site Request
Forgery) 攻撃から保護するために使用されます。認可リクエストにランダムな文字列を
`state`
パラメータとして含め、認可レスポンスでその値を検証することで、攻撃者が偽の認可レスポンスを送り込むことを防ぎます。

**4. リダイレクト URI の検証**: リダイレクト URI
は、認可サーバーが認可完了後にリソースオーナーをリダイレクトする URI
です。攻撃者が偽の URI
を登録することで認可コードを盗み出す可能性があるため、**クライアント登録時にリダイレクト
URI を適切に検証する**ことが重要です。

**5. HTTPS の使用**: OAuth 2.0 の通信は、**常に HTTPS
で保護する**必要があります。HTTPS
を使用することで、通信経路における盗聴や改ざんのリスクを軽減できます。

**6. アクセストークンの安全な管理**:
アクセストークンは、保護されたリソースへのアクセスを許可する重要な情報であるため、安全に管理する必要があります。トークンの有効期限を適切に設定し、必要最低限のスコープのみを付与することで、リスクを軽減できます。

**7. 最新のセキュリティベストプラクティスの参照**: OAuth 2.0
のセキュリティに関するベストプラクティスは、常に進化しています。OAuth 2.0
Security Best Current Practice や Financial-grade API (FAPI)
などの最新情報を参照し、システムに適切なセキュリティ対策を講じることが重要です。

これらのベストプラクティスに加えて、OAuth 2.0 / OpenID Connect
の実装には、以下の点にも注意する必要があります。

- **エラーレスポンスの適切な処理**:
  認可サーバーから返されるエラーレスポンスを適切に処理することで、予期せぬ動作を防ぐことができます。
- **トークンイントロスペクション**:
  アクセストークンの有効性を確認する仕組みを導入することで、不正なトークンの使用を防ぐことができます。
- **ログの監視**:
  認可サーバーやリソースサーバーのログを監視することで、不正アクセスの兆候を早期に発見することができます。
